package newprogsoftwares.estruturadedados.fj14;

public class LinkedList_fj14 implements DoubleLinked {

	Node first;
	Node last;

	private int totalizer;

	public LinkedList_fj14() {
		this.setTotalizer(0);
		this.first = null;
		this.last = null;
	}

	public Object pega(int position) {
		return this.catchNode(position).getElemento();
	}

	public int tamanho() {
		return this.totalizer;
	}

	public boolean contains() {
		return false;
	}

	public void addToStart(Object element) {

		Node aux = new Node(first, element);

		if (isVoid()) {
			last = first = aux;
			this.totalizer++;
			return;
		}

		last = first;
		first = aux;

		this.totalizer++;
	}

	public void add(Object element, int position) {

		if (position == 0) {
			this.addToStart(element);
		} else if (position == this.totalizer) {
			this.addToEnd(element);
		} else {
			// I recover the previous position.
			Node lastAux = this.catchNode(position - 1);
			// Create the new Node and indicate your next as the previous.next
			// Node.
			Node newAux = new Node(lastAux.getNext(), element);
			// indicate the new node to lastnode as your next.
			lastAux.setNext(newAux);
			this.totalizer++;
		}

	}

	public void addToEnd(Object element) {

		if (isVoid()) {
			this.addToStart(element);
		} else {

			Node nova = new Node(element);
			this.last.setNext(nova);
			this.last = nova;
			this.totalizer++;
		}
	}

	public void removeFromStart() {

		if (!this.isOcuppedPosition(0)) {
			throw new IllegalArgumentException("Out of Position!");
		}

		this.first = this.first.getNext();
		this.totalizer--;

		if (this.totalizer == 0) {
			this.last = null;
		}
	}

	public void removeFromEnd() {
		if (isOcuppedPosition(totalizer)) {
			if (totalizer == 1) {
				removeFromStart();
			} else {
				Node novo = catchNode(totalizer - 1);
				novo.setNext(null);
			}
		}
	};

	public void remove(int position) {
		if(!isOcuppedPosition(position)){
			throw new IllegalArgumentException("Position is null!");
		}
		if(position == 0){
			removeFromStart();
		}else if(position == this.totalizer){
			removeFromEnd(Boolean verdade);
		}
	}

	public Boolean isVoid() {
		return this.getTotalizer() > 0;
	}

	public int getTotalizer() {
		return totalizer;
	}

	public void setTotalizer(int totalizer) {
		this.totalizer = totalizer;
	}

	protected boolean isOcuppedPosition(int position) {
		return position >= 0 && position < this.totalizer;
	}

	private Node catchNode(int position) {

		if (!isOcuppedPosition(position)) {
			throw new IllegalArgumentException("Posição não Existente!");
		}

		Node current = first;

		for (int i = 0; i < position; i++) {
			current = (Node) current.getNext();
		}

		return current;
	}

	@Override
	public String toString() {

		if (isVoid()) {
			return "[]";
		}

		StringBuilder sb = new StringBuilder("[");
		Object atual = this.first;

		for (int i = 0; i < this.totalizer - 1; i++) {
			sb.append(((Node) atual).getElemento());
			sb.append(",");
			atual = ((Node) atual).getElemento();
		}

		sb.append(((Node) atual).getElemento());
		sb.append("]");

		return sb.toString();
	}

	@Override
	public void removeFromEnd_() {

		if (!isOcuppedPosition(totalizer - 1)) {
			throw new IllegalArgumentException("Posição não existente!");
		}

		if (getTotalizer() == 1) {
			this.removeFromStart();
		} else {
			Node before = this.last.getBefore();
			before.setNext(null);
			this.last = before;
			this.totalizer--;
		}

	}

}
